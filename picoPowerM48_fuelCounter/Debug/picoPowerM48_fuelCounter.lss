
picoPowerM48_fuelCounter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  00000516  000005aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000516  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000009  00800106  00800106  000005b0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005b0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000168  00000000  00000000  000005e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000d94  00000000  00000000  00000748  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000005cb  00000000  00000000  000014dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000785  00000000  00000000  00001aa7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000324  00000000  00000000  0000222c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000048f  00000000  00000000  00002550  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006f5  00000000  00000000  000029df  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000108  00000000  00000000  000030d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
*    Purpose:    Loads Current position in EEPROM.
*
*    Parameters: none
*    Returns: none
*------------------------------------------------------------*/
void EEPROM_GetCurrentPosition(void){
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	8a c1       	rjmp	.+788    	; 0x318 <__vector_1>
   4:	b6 c1       	rjmp	.+876    	; 0x372 <__vector_2>
   6:	31 c0       	rjmp	.+98     	; 0x6a <__bad_interrupt>
   8:	30 c0       	rjmp	.+96     	; 0x6a <__bad_interrupt>
   a:	2f c0       	rjmp	.+94     	; 0x6a <__bad_interrupt>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	2d c0       	rjmp	.+90     	; 0x6a <__bad_interrupt>
    uint8_t U8_value1,U8_value2;
    uint8_t U8_position;
    
    U8_value1 = EEPROM_read(STATUS_BUFFER_START_ADDRESS);
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	54 c1       	rjmp	.+680    	; 0x2bc <__vector_9>
  14:	2a c0       	rjmp	.+84     	; 0x6a <__bad_interrupt>
  16:	48 c1       	rjmp	.+656    	; 0x2a8 <__vector_11>
  18:	28 c0       	rjmp	.+80     	; 0x6a <__bad_interrupt>
  1a:	27 c0       	rjmp	.+78     	; 0x6a <__bad_interrupt>
  1c:	26 c0       	rjmp	.+76     	; 0x6a <__bad_interrupt>
  1e:	25 c0       	rjmp	.+74     	; 0x6a <__bad_interrupt>
  20:	24 c0       	rjmp	.+72     	; 0x6a <__bad_interrupt>
  22:	23 c0       	rjmp	.+70     	; 0x6a <__bad_interrupt>
  24:	22 c0       	rjmp	.+68     	; 0x6a <__bad_interrupt>
    
    for(U8_position=0;U8_position<19;U8_position++){
        
        U8_value2 = EEPROM_read(STATUS_BUFFER_START_ADDRESS + ((U8_position+1)%19));
  26:	21 c0       	rjmp	.+66     	; 0x6a <__bad_interrupt>
  28:	20 c0       	rjmp	.+64     	; 0x6a <__bad_interrupt>
  2a:	1f c0       	rjmp	.+62     	; 0x6a <__bad_interrupt>
  2c:	1e c0       	rjmp	.+60     	; 0x6a <__bad_interrupt>
  2e:	1d c0       	rjmp	.+58     	; 0x6a <__bad_interrupt>
  30:	1c c0       	rjmp	.+56     	; 0x6a <__bad_interrupt>
  32:	1b c0       	rjmp	.+54     	; 0x6a <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
        
        if(U8_value2 == (uint8_t)(U8_value1+1)){
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d2 e0       	ldi	r29, 0x02	; 2
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_copy_data>:
  40:	11 e0       	ldi	r17, 0x01	; 1
    uint8_t U8_value1,U8_value2;
    uint8_t U8_position;
    
    U8_value1 = EEPROM_read(STATUS_BUFFER_START_ADDRESS);
    
    for(U8_position=0;U8_position<19;U8_position++){
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
        
        U8_value2 = EEPROM_read(STATUS_BUFFER_START_ADDRESS + ((U8_position+1)%19));
        
        if(U8_value2 == (uint8_t)(U8_value1+1)){
            U8_value1 = U8_value2;
  46:	e6 e1       	ldi	r30, 0x16	; 22
  48:	f5 e0       	ldi	r31, 0x05	; 5
            
        }else{
            BufferPtr = U8_position;
  4a:	02 c0       	rjmp	.+4      	; 0x50 <__do_copy_data+0x10>
  4c:	05 90       	lpm	r0, Z+
            StatusBufferValue = U8_value1;
  4e:	0d 92       	st	X+, r0
  50:	a6 30       	cpi	r26, 0x06	; 6
            stat = BufferPtr;
  52:	b1 07       	cpc	r27, r17
  54:	d9 f7       	brne	.-10     	; 0x4c <__do_copy_data+0xc>

00000056 <__do_clear_bss>:
            break;
        }
    }
    if((0 == BufferPtr)&&(0xFF == EEPROM_read(FIRST_USE_LOCATION))){
  56:	21 e0       	ldi	r18, 0x01	; 1
  58:	a6 e0       	ldi	r26, 0x06	; 6
  5a:	b1 e0       	ldi	r27, 0x01	; 1
  5c:	01 c0       	rjmp	.+2      	; 0x60 <.do_clear_bss_start>

0000005e <.do_clear_bss_loop>:
  5e:	1d 92       	st	X+, r1

00000060 <.do_clear_bss_start>:
  60:	af 30       	cpi	r26, 0x0F	; 15
  62:	b2 07       	cpc	r27, r18
  64:	e1 f7       	brne	.-8      	; 0x5e <.do_clear_bss_loop>
        FirstWrite = 1;
  66:	94 d1       	rcall	.+808    	; 0x390 <main>
  68:	54 c2       	rjmp	.+1192   	; 0x512 <_exit>

0000006a <__bad_interrupt>:
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

0000006c <Download_Function>:
    }    
  6c:	df 92       	push	r13
  6e:	ef 92       	push	r14
  70:	ff 92       	push	r15
  72:	0f 93       	push	r16
  74:	1f 93       	push	r17
  76:	cf 93       	push	r28
  78:	df 93       	push	r29
  7a:	1f 92       	push	r1
  7c:	cd b7       	in	r28, 0x3d	; 61
*    Purpose:    Handles BT communication
*
*    Parameters:        none
*    Returns:    none
*------------------------------------------------------------*/
void Download_Function(void){
  7e:	de b7       	in	r29, 0x3e	; 62
    
    uint8_t adcv;
    uint8_t uart_data = 0;
  80:	19 82       	std	Y+1, r1	; 0x01
    Timer2_Stop();
  82:	c9 d0       	rcall	.+402    	; 0x216 <Timer2_Stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  84:	2f ef       	ldi	r18, 0xFF	; 255
  86:	87 e6       	ldi	r24, 0x67	; 103
  88:	91 e0       	ldi	r25, 0x01	; 1
  8a:	21 50       	subi	r18, 0x01	; 1
  8c:	80 40       	sbci	r24, 0x00	; 0
  8e:	90 40       	sbci	r25, 0x00	; 0
  90:	e1 f7       	brne	.-8      	; 0x8a <Download_Function+0x1e>
  92:	00 c0       	rjmp	.+0      	; 0x94 <Download_Function+0x28>
  94:	00 00       	nop
    
    _delay_ms(500);
    ADC_Init();
  96:	ed d0       	rcall	.+474    	; 0x272 <ADC_Init>
    
    
                    
        while(0 == USART_Receive(&uart_data))
  98:	ce 01       	movw	r24, r28
  9a:	01 96       	adiw	r24, 0x01	; 1
  9c:	6e d0       	rcall	.+220    	; 0x17a <USART_Receive>
  9e:	88 23       	and	r24, r24
  a0:	d9 f3       	breq	.-10     	; 0x98 <Download_Function+0x2c>
            ;
        do{
            uart_data = 0;
  a2:	19 82       	std	Y+1, r1	; 0x01
             USART_Receive(&uart_data);
  a4:	ce 01       	movw	r24, r28
  a6:	01 96       	adiw	r24, 0x01	; 1
  a8:	68 d0       	rcall	.+208    	; 0x17a <USART_Receive>
        }while(uart_data!=0x0A);
  aa:	89 81       	ldd	r24, Y+1	; 0x01
  ac:	8a 30       	cpi	r24, 0x0A	; 10
  ae:	c9 f7       	brne	.-14     	; 0xa2 <Download_Function+0x36>
    while(0 != (PIND&0x08)){            
    
        adcv=ADC_GetVal();
        adcv=ADC_GetVal();
                
        USART_Transmit(0x30+(adcv/100));
  b0:	0f 2e       	mov	r0, r31
  b2:	f9 e2       	ldi	r31, 0x29	; 41
  b4:	df 2e       	mov	r13, r31
  b6:	f0 2d       	mov	r31, r0
        USART_Transmit(0x30+((adcv%100)/10));
  b8:	0f 2e       	mov	r0, r31
  ba:	f4 e6       	ldi	r31, 0x64	; 100
  bc:	ef 2e       	mov	r14, r31
  be:	f0 2d       	mov	r31, r0
  c0:	0f 2e       	mov	r0, r31
  c2:	fd ec       	ldi	r31, 0xCD	; 205
  c4:	ff 2e       	mov	r15, r31
  c6:	f0 2d       	mov	r31, r0
  c8:	3f c0       	rjmp	.+126    	; 0x148 <Download_Function+0xdc>
             USART_Receive(&uart_data);
        }while(uart_data!=0x0A);
        
    while(0 != (PIND&0x08)){            
    
        adcv=ADC_GetVal();
  ca:	81 d0       	rcall	.+258    	; 0x1ce <ADC_GetVal>
        adcv=ADC_GetVal();
  cc:	80 d0       	rcall	.+256    	; 0x1ce <ADC_GetVal>
  ce:	18 2f       	mov	r17, r24
                
        USART_Transmit(0x30+(adcv/100));
  d0:	8d 9d       	mul	r24, r13
  d2:	01 2d       	mov	r16, r1
  d4:	11 24       	eor	r1, r1
  d6:	02 95       	swap	r16
  d8:	0f 70       	andi	r16, 0x0F	; 15
  da:	80 e3       	ldi	r24, 0x30	; 48
  dc:	80 0f       	add	r24, r16
  de:	45 d0       	rcall	.+138    	; 0x16a <USART_Transmit>
        USART_Transmit(0x30+((adcv%100)/10));
  e0:	81 2f       	mov	r24, r17
  e2:	0e 9d       	mul	r16, r14
  e4:	80 19       	sub	r24, r0
  e6:	11 24       	eor	r1, r1
  e8:	8f 9d       	mul	r24, r15
  ea:	81 2d       	mov	r24, r1
  ec:	11 24       	eor	r1, r1
  ee:	86 95       	lsr	r24
  f0:	86 95       	lsr	r24
  f2:	86 95       	lsr	r24
  f4:	80 5d       	subi	r24, 0xD0	; 208
  f6:	39 d0       	rcall	.+114    	; 0x16a <USART_Transmit>
        USART_Transmit(0x30+(adcv%10));
  f8:	1f 9d       	mul	r17, r15
  fa:	81 2d       	mov	r24, r1
  fc:	11 24       	eor	r1, r1
  fe:	86 95       	lsr	r24
 100:	86 95       	lsr	r24
 102:	86 95       	lsr	r24
 104:	88 0f       	add	r24, r24
 106:	98 2f       	mov	r25, r24
 108:	99 0f       	add	r25, r25
 10a:	99 0f       	add	r25, r25
 10c:	89 0f       	add	r24, r25
 10e:	18 1b       	sub	r17, r24
 110:	81 2f       	mov	r24, r17
 112:	80 5d       	subi	r24, 0xD0	; 208
 114:	2a d0       	rcall	.+84     	; 0x16a <USART_Transmit>
        
        USART_Transmit(0x0D);
 116:	8d e0       	ldi	r24, 0x0D	; 13
 118:	28 d0       	rcall	.+80     	; 0x16a <USART_Transmit>
        USART_Transmit(0x0A);
 11a:	8a e0       	ldi	r24, 0x0A	; 10
 11c:	26 d0       	rcall	.+76     	; 0x16a <USART_Transmit>
 11e:	2f ef       	ldi	r18, 0xFF	; 255
 120:	87 e6       	ldi	r24, 0x67	; 103
 122:	91 e0       	ldi	r25, 0x01	; 1
 124:	21 50       	subi	r18, 0x01	; 1
 126:	80 40       	sbci	r24, 0x00	; 0
 128:	90 40       	sbci	r25, 0x00	; 0
 12a:	e1 f7       	brne	.-8      	; 0x124 <Download_Function+0xb8>
 12c:	00 c0       	rjmp	.+0      	; 0x12e <Download_Function+0xc2>
 12e:	00 00       	nop
            
        _delay_ms(500);
        
        while(0 == USART_Receive(&uart_data))
 130:	ce 01       	movw	r24, r28
 132:	01 96       	adiw	r24, 0x01	; 1
 134:	22 d0       	rcall	.+68     	; 0x17a <USART_Receive>
 136:	88 23       	and	r24, r24
 138:	d9 f3       	breq	.-10     	; 0x130 <Download_Function+0xc4>
            ;
        do{
            uart_data = 0;
 13a:	19 82       	std	Y+1, r1	; 0x01
            USART_Receive(&uart_data);
 13c:	ce 01       	movw	r24, r28
 13e:	01 96       	adiw	r24, 0x01	; 1
 140:	1c d0       	rcall	.+56     	; 0x17a <USART_Receive>
        }while(uart_data!=0x0A);
 142:	89 81       	ldd	r24, Y+1	; 0x01
 144:	8a 30       	cpi	r24, 0x0A	; 10
 146:	c9 f7       	brne	.-14     	; 0x13a <Download_Function+0xce>
        do{
            uart_data = 0;
             USART_Receive(&uart_data);
        }while(uart_data!=0x0A);
        
    while(0 != (PIND&0x08)){            
 148:	4b 99       	sbic	0x09, 3	; 9
 14a:	bf cf       	rjmp	.-130    	; 0xca <Download_Function+0x5e>
            uart_data = 0;
            USART_Receive(&uart_data);
        }while(uart_data!=0x0A);
    }
    
    power_adc_disable();
 14c:	e4 e6       	ldi	r30, 0x64	; 100
 14e:	f0 e0       	ldi	r31, 0x00	; 0
 150:	80 81       	ld	r24, Z
 152:	81 60       	ori	r24, 0x01	; 1
 154:	80 83       	st	Z, r24
    sleep_cpu();
 156:	88 95       	sleep
    
} 
 158:	0f 90       	pop	r0
 15a:	df 91       	pop	r29
 15c:	cf 91       	pop	r28
 15e:	1f 91       	pop	r17
 160:	0f 91       	pop	r16
 162:	ff 90       	pop	r15
 164:	ef 90       	pop	r14
 166:	df 90       	pop	r13
 168:	08 95       	ret

0000016a <USART_Transmit>:
void USART_Transmit(uint8_t data){
    /* Wait for empty transmit buffer */
//    while(!(UCSR0A & (1<<UDRE0)));  // Make sure that the data register is empty before putting the device to sleep
//        ;
    /* Put data into buffer, sends the data */
    UDR0 = data;
 16a:	80 93 c6 00 	sts	0x00C6, r24
    /* Wait for empty transmit buffer */
    while(!(UCSR0A & (1<<UDRE0)));  // Make sure that the data register is empty before putting the device to sleep
 16e:	e0 ec       	ldi	r30, 0xC0	; 192
 170:	f0 e0       	ldi	r31, 0x00	; 0
 172:	80 81       	ld	r24, Z
 174:	85 ff       	sbrs	r24, 5
 176:	fd cf       	rjmp	.-6      	; 0x172 <USART_Transmit+0x8>
        ;    
}
 178:	08 95       	ret

0000017a <USART_Receive>:
*    Returns: none
*------------------------------------------------------------*/
uint8_t USART_Receive(uint8_t * data)
{
    /* Wait for data to be received */
    if(UCSR0A & (1<<RXC0)){
 17a:	20 91 c0 00 	lds	r18, 0x00C0
 17e:	22 23       	and	r18, r18
 180:	34 f4       	brge	.+12     	; 0x18e <USART_Receive+0x14>
    /* Get and return received data from buffer */
    *data = UDR0;
 182:	20 91 c6 00 	lds	r18, 0x00C6
 186:	fc 01       	movw	r30, r24
 188:	20 83       	st	Z, r18
    return 1;
 18a:	81 e0       	ldi	r24, 0x01	; 1
 18c:	08 95       	ret
    }else
        return 0;    
 18e:	80 e0       	ldi	r24, 0x00	; 0
}
 190:	08 95       	ret

00000192 <USART_print>:
*
*    Parameters: 
*        text - pointer to byte array (string)
*    Returns: none
*------------------------------------------------------------*/
void USART_print(char * text){
 192:	0f 93       	push	r16
 194:	1f 93       	push	r17
 196:	cf 93       	push	r28
 198:	df 93       	push	r29
    
    uint8_t text_size=strlen(text);    
 19a:	fc 01       	movw	r30, r24
 19c:	01 90       	ld	r0, Z+
 19e:	00 20       	and	r0, r0
 1a0:	e9 f7       	brne	.-6      	; 0x19c <USART_print+0xa>
 1a2:	31 97       	sbiw	r30, 0x01	; 1
 1a4:	1e 2f       	mov	r17, r30
 1a6:	18 1b       	sub	r17, r24
    uint8_t i;
    
    for(i=0;i<text_size;i++){
 1a8:	49 f0       	breq	.+18     	; 0x1bc <USART_print+0x2a>
 1aa:	08 2f       	mov	r16, r24
 1ac:	c0 2f       	mov	r28, r16
 1ae:	d9 2f       	mov	r29, r25
        USART_Transmit(text[i]);        
 1b0:	89 91       	ld	r24, Y+
 1b2:	db df       	rcall	.-74     	; 0x16a <USART_Transmit>
 1b4:	8c 2f       	mov	r24, r28
 1b6:	80 1b       	sub	r24, r16
void USART_print(char * text){
    
    uint8_t text_size=strlen(text);    
    uint8_t i;
    
    for(i=0;i<text_size;i++){
 1b8:	81 17       	cp	r24, r17
 1ba:	d0 f3       	brcs	.-12     	; 0x1b0 <USART_print+0x1e>
        USART_Transmit(text[i]);        
    }
    USART_Transmit(0x0D);
 1bc:	8d e0       	ldi	r24, 0x0D	; 13
 1be:	d5 df       	rcall	.-86     	; 0x16a <USART_Transmit>
    USART_Transmit(0x0A);
 1c0:	8a e0       	ldi	r24, 0x0A	; 10
 1c2:	d3 df       	rcall	.-90     	; 0x16a <USART_Transmit>
}
 1c4:	df 91       	pop	r29
 1c6:	cf 91       	pop	r28
 1c8:	1f 91       	pop	r17
 1ca:	0f 91       	pop	r16
 1cc:	08 95       	ret

000001ce <ADC_GetVal>:
*        ADC value.
*------------------------------------------------------------*/
uint8_t ADC_GetVal(void){
    uint8_t return_val=0;
    // Start an ADC conversion
    ADCSRA|=(1<<ADSC);
 1ce:	ea e7       	ldi	r30, 0x7A	; 122
 1d0:	f0 e0       	ldi	r31, 0x00	; 0
 1d2:	80 81       	ld	r24, Z
 1d4:	80 64       	ori	r24, 0x40	; 64
 1d6:	80 83       	st	Z, r24
    // Wait the conversion to be completed
    while((1<<ADIF)&ADCSRA)
 1d8:	80 81       	ld	r24, Z
 1da:	84 fd       	sbrc	r24, 4
 1dc:	fd cf       	rjmp	.-6      	; 0x1d8 <ADC_GetVal+0xa>
        ;
    return_val = (uint8_t)(ADCW>>2);
 1de:	80 91 78 00 	lds	r24, 0x0078
 1e2:	90 91 79 00 	lds	r25, 0x0079
 1e6:	96 95       	lsr	r25
 1e8:	87 95       	ror	r24
 1ea:	96 95       	lsr	r25
 1ec:	87 95       	ror	r24
    return return_val;
}
 1ee:	08 95       	ret

000001f0 <Init_Timer2>:
*
*    Parameters:    none
*    Returns: none
*------------------------------------------------------------*/
void Init_Timer2(void){
    TCCR2B = 0;
 1f0:	10 92 b1 00 	sts	0x00B1, r1
    //Enable timer2 overflow interrupt
    TIMSK2 = (1<<TOIE2);         
 1f4:	81 e0       	ldi	r24, 0x01	; 1
 1f6:	80 93 70 00 	sts	0x0070, r24
    //count 225 for 4Hz       
    TCNT2 = 30;        
 1fa:	8e e1       	ldi	r24, 0x1E	; 30
 1fc:	80 93 b2 00 	sts	0x00B2, r24
    //Enable async operation                    
    ASSR = (1<<AS2);                    
 200:	80 e2       	ldi	r24, 0x20	; 32
 202:	80 93 b6 00 	sts	0x00B6, r24
 206:	08 95       	ret

00000208 <Timer2_Start>:
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void Timer2_Start(void){
    //count 225 for 4Hz
    TCNT2 = 30;        
 208:	8e e1       	ldi	r24, 0x1E	; 30
 20a:	80 93 b2 00 	sts	0x00B2, r24
    //Clock prescaler set to 1024, overflow 4 timer each sec                    
    TCCR2B = (1<<CS20) | (1<<CS21) | (1<<CS22);         
 20e:	87 e0       	ldi	r24, 0x07	; 7
 210:	80 93 b1 00 	sts	0x00B1, r24
 214:	08 95       	ret

00000216 <Timer2_Stop>:
*
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void Timer2_Stop(void){
    TCCR2B = 0;    
 216:	10 92 b1 00 	sts	0x00B1, r1
 21a:	08 95       	ret

0000021c <EXT_Int_Init>:
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void EXT_Int_Init(void){
            //Rising edge INT1  //  Falling edge INT0
    EICRA = (1<<ISC11) | (1<<ISC10) | (1<<ISC01) | (0<<ISC00); 
 21c:	8e e0       	ldi	r24, 0x0E	; 14
 21e:	80 93 69 00 	sts	0x0069, r24
    // set enable flags in int mask
    EIMSK = (1<<INT1) | (1<<INT0);                               
 222:	83 e0       	ldi	r24, 0x03	; 3
 224:	8d bb       	out	0x1d, r24	; 29
 226:	08 95       	ret

00000228 <Init_Port>:
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void Init_Port(void){
    //All pins are input
    DDRB = 0x00; 
 228:	14 b8       	out	0x04, r1	; 4
    DDRC = 0x00;
 22a:	17 b8       	out	0x07, r1	; 7
    DDRD = 0x00;
 22c:	1a b8       	out	0x0a, r1	; 10
    //All ports are state low
    PORTB = 0x00;   
 22e:	15 b8       	out	0x05, r1	; 5
    PORTC = 0x00;   // The UART tx pin will still work
 230:	18 b8       	out	0x08, r1	; 8
    PORTD = 0x00;
 232:	1b b8       	out	0x0b, r1	; 11
 234:	08 95       	ret

00000236 <Init_Uart>:
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void Init_Uart(void){
    // Enable U2Xn to get a baud rate with less error margin
    UCSR0A = (1<<U2X0);       
 236:	82 e0       	ldi	r24, 0x02	; 2
 238:	80 93 c0 00 	sts	0x00C0, r24
     // Transmitter enable and Receiver enable                  
    UCSR0B = (1<<TXEN0)|(1<<RXEN0);           
 23c:	88 e1       	ldi	r24, 0x18	; 24
 23e:	80 93 c1 00 	sts	0x00C1, r24
    // Asynchronous USART | No parity | 1 stopbit | CH size 8-bit    
    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01) | (1<<USBS0);
 242:	8e e0       	ldi	r24, 0x0E	; 14
 244:	80 93 c2 00 	sts	0x00C2, r24
    // 115200 Baudrate @ 0.9216 Mhz
    UBRR0L = 0;                                        
 248:	10 92 c4 00 	sts	0x00C4, r1
 24c:	08 95       	ret

0000024e <Enable_PRR>:
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void Enable_PRR(void){
    //cut power for spi
    power_spi_disable();
 24e:	e4 e6       	ldi	r30, 0x64	; 100
 250:	f0 e0       	ldi	r31, 0x00	; 0
 252:	80 81       	ld	r24, Z
 254:	84 60       	ori	r24, 0x04	; 4
 256:	80 83       	st	Z, r24
    //cut power for timer 0
    power_timer0_disable();
 258:	80 81       	ld	r24, Z
 25a:	80 62       	ori	r24, 0x20	; 32
 25c:	80 83       	st	Z, r24
    //cut power for timer 1
    power_timer1_disable();
 25e:	80 81       	ld	r24, Z
 260:	88 60       	ori	r24, 0x08	; 8
 262:	80 83       	st	Z, r24
    //cut power for timer 2
    //    power_timer2_disable();
    //cut power for twi
    power_twi_disable();
 264:	80 81       	ld	r24, Z
 266:	80 68       	ori	r24, 0x80	; 128
 268:	80 83       	st	Z, r24
    //cut power for adc
    power_adc_disable();
 26a:	80 81       	ld	r24, Z
 26c:	81 60       	ori	r24, 0x01	; 1
 26e:	80 83       	st	Z, r24
 270:	08 95       	ret

00000272 <ADC_Init>:
*
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void ADC_Init(void){
    power_adc_enable();
 272:	e4 e6       	ldi	r30, 0x64	; 100
 274:	f0 e0       	ldi	r31, 0x00	; 0
 276:	80 81       	ld	r24, Z
 278:	8e 7f       	andi	r24, 0xFE	; 254
 27a:	80 83       	st	Z, r24
    //Set the Band Gap voltage as the ADC input
    ADMUX = (1<<MUX3)|(1<<MUX2)|(1<<MUX1)|(1<<REFS0);
 27c:	8e e4       	ldi	r24, 0x4E	; 78
 27e:	80 93 7c 00 	sts	0x007C, r24
    // ADC en, 128 division factor
    ADCSRA = (1<<ADEN)|(1<<ADPS2)|(1<<ADPS0);
 282:	85 e8       	ldi	r24, 0x85	; 133
 284:	80 93 7a 00 	sts	0x007A, r24
 288:	08 95       	ret

0000028a <Mcu_Init>:
*    Parameters:    none
*    Returns:    none
*------------------------------------------------------------*/
void Mcu_Init(void){
    //disable interrupts
    cli(); 
 28a:	f8 94       	cli
    
    //    clock_prescale_set(clock_div_4);

    Init_Port();
 28c:	cd df       	rcall	.-102    	; 0x228 <Init_Port>
    //    Init_Timer();
    Init_Uart();
 28e:	d3 df       	rcall	.-90     	; 0x236 <Init_Uart>
    EXT_Int_Init();
 290:	c5 df       	rcall	.-118    	; 0x21c <EXT_Int_Init>
    Init_Timer2();
 292:	ae df       	rcall	.-164    	; 0x1f0 <Init_Timer2>
    
    Enable_PRR();
 294:	dc df       	rcall	.-72     	; 0x24e <Enable_PRR>
    //    ADC_Init();
    
    //    set_sleep_mode(SLEEP_MODE_IDLE); 
    
    // Set sleep mode to Power-save
    set_sleep_mode(SLEEP_MODE_PWR_SAVE); 
 296:	83 b7       	in	r24, 0x33	; 51
 298:	81 7f       	andi	r24, 0xF1	; 241
 29a:	86 60       	ori	r24, 0x06	; 6
 29c:	83 bf       	out	0x33, r24	; 51
    // Enable sleep (possible to put the device into sleep mode
    // when executing the sleep function)
    sleep_enable();                      
 29e:	83 b7       	in	r24, 0x33	; 51
 2a0:	81 60       	ori	r24, 0x01	; 1
 2a2:	83 bf       	out	0x33, r24	; 51
    //    clock_prescale_set(clock_div_4);
    //enable interrupts
    sei();
 2a4:	78 94       	sei
 2a6:	08 95       	ret

000002a8 <__vector_11>:

static int tmr2_cnt=0;
/*
 * Timer 1 Interrupt routine
 */
ISR(TIMER1_COMPA_vect){
 2a8:	1f 92       	push	r1
 2aa:	0f 92       	push	r0
 2ac:	0f b6       	in	r0, 0x3f	; 63
 2ae:	0f 92       	push	r0
 2b0:	11 24       	eor	r1, r1
    //OCR1A = 14400;
//    seconds++;
//    state |= ONE_SECOND_INT;    
}    
 2b2:	0f 90       	pop	r0
 2b4:	0f be       	out	0x3f, r0	; 63
 2b6:	0f 90       	pop	r0
 2b8:	1f 90       	pop	r1
 2ba:	18 95       	reti

000002bc <__vector_9>:

/*
 * Timer 1 Interrupt routine
 */
ISR(TIMER2_OVF_vect){
 2bc:	1f 92       	push	r1
 2be:	0f 92       	push	r0
 2c0:	0f b6       	in	r0, 0x3f	; 63
 2c2:	0f 92       	push	r0
 2c4:	11 24       	eor	r1, r1
 2c6:	2f 93       	push	r18
 2c8:	8f 93       	push	r24
 2ca:	9f 93       	push	r25
    TCNT2 = 30;
 2cc:	8e e1       	ldi	r24, 0x1E	; 30
 2ce:	80 93 b2 00 	sts	0x00B2, r24
    tmr2_cnt += 225;
 2d2:	80 91 06 01 	lds	r24, 0x0106
 2d6:	90 91 07 01 	lds	r25, 0x0107
 2da:	8f 51       	subi	r24, 0x1F	; 31
 2dc:	9f 4f       	sbci	r25, 0xFF	; 255
 2de:	90 93 07 01 	sts	0x0107, r25
 2e2:	80 93 06 01 	sts	0x0106, r24
    if(900 == tmr2_cnt){
 2e6:	84 38       	cpi	r24, 0x84	; 132
 2e8:	93 40       	sbci	r25, 0x03	; 3
 2ea:	71 f4       	brne	.+28     	; 0x308 <__stack+0x9>
        seconds++;
 2ec:	80 91 08 01 	lds	r24, 0x0108
 2f0:	8f 5f       	subi	r24, 0xFF	; 255
 2f2:	80 93 08 01 	sts	0x0108, r24
        tmr2_cnt = 0;
 2f6:	10 92 07 01 	sts	0x0107, r1
 2fa:	10 92 06 01 	sts	0x0106, r1
        state |= ONE_SECOND_INT;    
 2fe:	80 91 0b 01 	lds	r24, 0x010B
 302:	82 60       	ori	r24, 0x02	; 2
 304:	80 93 0b 01 	sts	0x010B, r24
    }        
}
 308:	9f 91       	pop	r25
 30a:	8f 91       	pop	r24
 30c:	2f 91       	pop	r18
 30e:	0f 90       	pop	r0
 310:	0f be       	out	0x3f, r0	; 63
 312:	0f 90       	pop	r0
 314:	1f 90       	pop	r1
 316:	18 95       	reti

00000318 <__vector_1>:

/*
 * Fuel impulse signal interrupt routine
 */
ISR(INT0_vect){
 318:	1f 92       	push	r1
 31a:	0f 92       	push	r0
 31c:	0f b6       	in	r0, 0x3f	; 63
 31e:	0f 92       	push	r0
 320:	11 24       	eor	r1, r1
 322:	2f 93       	push	r18
 324:	8f 93       	push	r24
 326:	9f 93       	push	r25
 328:	ef 93       	push	r30
 32a:	ff 93       	push	r31
    //ticks = TCNT1;
    //TCNT1 = 0;
    ticks = tmr2_cnt + TCNT2 - 30; //add counted timer minus tmr starting time (30)
 32c:	e2 eb       	ldi	r30, 0xB2	; 178
 32e:	f0 e0       	ldi	r31, 0x00	; 0
 330:	20 81       	ld	r18, Z
 332:	80 91 06 01 	lds	r24, 0x0106
 336:	90 91 07 01 	lds	r25, 0x0107
 33a:	82 0f       	add	r24, r18
 33c:	91 1d       	adc	r25, r1
 33e:	4e 97       	sbiw	r24, 0x1e	; 30
 340:	90 93 0a 01 	sts	0x010A, r25
 344:	80 93 09 01 	sts	0x0109, r24
    tmr2_cnt = 0;  // reset sw counter
 348:	10 92 07 01 	sts	0x0107, r1
 34c:	10 92 06 01 	sts	0x0106, r1
    TCNT2 = 30;        //reset tmr2 counter to default for 4 hz
 350:	8e e1       	ldi	r24, 0x1E	; 30
 352:	80 83       	st	Z, r24
    state |= IMPULSE;    
 354:	80 91 0b 01 	lds	r24, 0x010B
 358:	81 60       	ori	r24, 0x01	; 1
 35a:	80 93 0b 01 	sts	0x010B, r24
}
 35e:	ff 91       	pop	r31
 360:	ef 91       	pop	r30
 362:	9f 91       	pop	r25
 364:	8f 91       	pop	r24
 366:	2f 91       	pop	r18
 368:	0f 90       	pop	r0
 36a:	0f be       	out	0x3f, r0	; 63
 36c:	0f 90       	pop	r0
 36e:	1f 90       	pop	r1
 370:	18 95       	reti

00000372 <__vector_2>:

/*
 * Button Interrupt routine
 * Open BT connection 
 */
ISR(INT1_vect){
 372:	1f 92       	push	r1
 374:	0f 92       	push	r0
 376:	0f b6       	in	r0, 0x3f	; 63
 378:	0f 92       	push	r0
 37a:	11 24       	eor	r1, r1
 37c:	8f 93       	push	r24
    state = BT_CONNECTED;    
 37e:	84 e0       	ldi	r24, 0x04	; 4
 380:	80 93 0b 01 	sts	0x010B, r24
//    USART_Transmit('v');
}
 384:	8f 91       	pop	r24
 386:	0f 90       	pop	r0
 388:	0f be       	out	0x3f, r0	; 63
 38a:	0f 90       	pop	r0
 38c:	1f 90       	pop	r1
 38e:	18 95       	reti

00000390 <main>:
    CurrentDuration              = &CurrentData.Duration;
    CurrentDuration->Seconds  = 0;
    CurrentConsumption          = &CurrentData.Consumption;
    uint16_t                    ml_consumption;

    Mcu_Init();
 390:	7c df       	rcall	.-264    	; 0x28a <Mcu_Init>
    USART_print("main");
 392:	80 e0       	ldi	r24, 0x00	; 0
 394:	91 e0       	ldi	r25, 0x01	; 1
 396:	fd de       	rcall	.-518    	; 0x192 <USART_print>
    // Set sleep mode to Power-save
    set_sleep_mode(SLEEP_MODE_PWR_DOWN); 
 398:	83 b7       	in	r24, 0x33	; 51
 39a:	81 7f       	andi	r24, 0xF1	; 241
 39c:	84 60       	ori	r24, 0x04	; 4
 39e:	83 bf       	out	0x33, r24	; 51
    //If reset occurs during BT connection
    Download_Function();
 3a0:	65 de       	rcall	.-822    	; 0x6c <Download_Function>
    
    // Execute sleep instruction
    sleep_cpu();
 3a2:	88 95       	sleep
    //int i=0;
    consumptionInfo_t            CurrentData;
    runningTime_t                * CurrentDuration;
    fuelConsumption_t            * CurrentConsumption;
    CurrentDuration              = &CurrentData.Duration;
    CurrentDuration->Seconds  = 0;
 3a4:	10 e0       	ldi	r17, 0x00	; 0
            //    USART_Transmit(0x30 + seconds);
                seconds = 0;
            }
            ticks= 0 ;
            
            CurrentDuration->Seconds += timerTicks / ONE_SECOND_TICKS;
 3a6:	c4 e8       	ldi	r28, 0x84	; 132
 3a8:	d3 e0       	ldi	r29, 0x03	; 3
            timerTicks = timerTicks % ONE_SECOND_TICKS;
            CurrentDuration->Minutes += CurrentDuration->Seconds / 60;
 3aa:	0f 2e       	mov	r0, r31
 3ac:	f9 e8       	ldi	r31, 0x89	; 137
 3ae:	ff 2e       	mov	r15, r31
 3b0:	f0 2d       	mov	r31, r0
            timeToSave               += CurrentDuration->Seconds / 60;
            CurrentDuration->Seconds  = CurrentDuration->Seconds % 60;
 3b2:	0c e3       	ldi	r16, 0x3C	; 60
//sei();
    //EEPROM_GetCurrentPosition();
    //EEPROM_loadData(&test);
    while(1)
    {
    switch(state){
 3b4:	80 91 0b 01 	lds	r24, 0x010B
 3b8:	82 30       	cpi	r24, 0x02	; 2
 3ba:	09 f4       	brne	.+2      	; 0x3be <main+0x2e>
 3bc:	76 c0       	rjmp	.+236    	; 0x4aa <main+0x11a>
 3be:	30 f4       	brcc	.+12     	; 0x3cc <main+0x3c>
 3c0:	88 23       	and	r24, r24
 3c2:	09 f4       	brne	.+2      	; 0x3c6 <main+0x36>
 3c4:	8c c0       	rjmp	.+280    	; 0x4de <main+0x14e>
 3c6:	81 30       	cpi	r24, 0x01	; 1
 3c8:	39 f0       	breq	.+14     	; 0x3d8 <main+0x48>
 3ca:	86 c0       	rjmp	.+268    	; 0x4d8 <main+0x148>
 3cc:	83 30       	cpi	r24, 0x03	; 3
 3ce:	21 f0       	breq	.+8      	; 0x3d8 <main+0x48>
 3d0:	84 30       	cpi	r24, 0x04	; 4
 3d2:	09 f4       	brne	.+2      	; 0x3d6 <main+0x46>
 3d4:	7b c0       	rjmp	.+246    	; 0x4cc <main+0x13c>
 3d6:	80 c0       	rjmp	.+256    	; 0x4d8 <main+0x148>
            //USART_Transmit('b');
        }
        case IMPULSE:{
        //    USART_Transmit('x');
        
        Timer2_Start();
 3d8:	17 df       	rcall	.-466    	; 0x208 <Timer2_Start>
    // Set sleep mode to Power-save
    set_sleep_mode(SLEEP_MODE_PWR_SAVE);
 3da:	83 b7       	in	r24, 0x33	; 51
 3dc:	81 7f       	andi	r24, 0xF1	; 241
 3de:	86 60       	ori	r24, 0x06	; 6
 3e0:	83 bf       	out	0x33, r24	; 51
    
            timerTicks += ticks;
 3e2:	80 91 09 01 	lds	r24, 0x0109
 3e6:	90 91 0a 01 	lds	r25, 0x010A
 3ea:	20 91 0d 01 	lds	r18, 0x010D
 3ee:	30 91 0e 01 	lds	r19, 0x010E
 3f2:	28 0f       	add	r18, r24
 3f4:	39 1f       	adc	r19, r25
 3f6:	30 93 0e 01 	sts	0x010E, r19
 3fa:	20 93 0d 01 	sts	0x010D, r18
            
            if(0 == seconds){
 3fe:	20 91 08 01 	lds	r18, 0x0108
 402:	21 11       	cpse	r18, r1
 404:	23 c0       	rjmp	.+70     	; 0x44c <main+0xbc>

                if(ticks < INTERVAL_1_HIGH){
 406:	88 3f       	cpi	r24, 0xF8	; 248
 408:	91 05       	cpc	r25, r1
 40a:	18 f4       	brcc	.+6      	; 0x412 <main+0x82>
                    ml_consumption = CONS_1_UL;
                    USART_Transmit('1');
 40c:	81 e3       	ldi	r24, 0x31	; 49
 40e:	ad de       	rcall	.-678    	; 0x16a <USART_Transmit>
 410:	24 c0       	rjmp	.+72     	; 0x45a <main+0xca>
                }else if((ticks > INTERVAL_1_HIGH)&&(ticks < INTERVAL_2_HIGH)){
 412:	9c 01       	movw	r18, r24
 414:	29 5f       	subi	r18, 0xF9	; 249
 416:	31 09       	sbc	r19, r1
 418:	27 31       	cpi	r18, 0x17	; 23
 41a:	31 05       	cpc	r19, r1
 41c:	18 f4       	brcc	.+6      	; 0x424 <main+0x94>
                    ml_consumption = CONS_2_UL;
                    USART_Transmit('2');
 41e:	82 e3       	ldi	r24, 0x32	; 50
 420:	a4 de       	rcall	.-696    	; 0x16a <USART_Transmit>
 422:	1b c0       	rjmp	.+54     	; 0x45a <main+0xca>
                }else if((ticks > INTERVAL_2_HIGH)&&(ticks < INTERVAL_3_HIGH)){
 424:	9c 01       	movw	r18, r24
 426:	21 51       	subi	r18, 0x11	; 17
 428:	31 40       	sbci	r19, 0x01	; 1
 42a:	20 3a       	cpi	r18, 0xA0	; 160
 42c:	31 05       	cpc	r19, r1
 42e:	18 f4       	brcc	.+6      	; 0x436 <main+0xa6>
                    ml_consumption = CONS_3_UL;
                    USART_Transmit('3');
 430:	83 e3       	ldi	r24, 0x33	; 51
 432:	9b de       	rcall	.-714    	; 0x16a <USART_Transmit>
 434:	12 c0       	rjmp	.+36     	; 0x45a <main+0xca>
                }else if((ticks > INTERVAL_3_HIGH)&&(ticks < INTERVAL_4_HIGH)){
 436:	82 5b       	subi	r24, 0xB2	; 178
 438:	91 40       	sbci	r25, 0x01	; 1
 43a:	88 3c       	cpi	r24, 0xC8	; 200
 43c:	91 05       	cpc	r25, r1
 43e:	18 f4       	brcc	.+6      	; 0x446 <main+0xb6>
                    ml_consumption = CONS_4_UL;
                    USART_Transmit('4');                    
 440:	84 e3       	ldi	r24, 0x34	; 52
 442:	93 de       	rcall	.-730    	; 0x16a <USART_Transmit>
 444:	0a c0       	rjmp	.+20     	; 0x45a <main+0xca>
                }else{
                    ml_consumption = CONS_5_UL;
                    USART_Transmit('5');
 446:	85 e3       	ldi	r24, 0x35	; 53
 448:	90 de       	rcall	.-736    	; 0x16a <USART_Transmit>
 44a:	07 c0       	rjmp	.+14     	; 0x45a <main+0xca>
                }
            }else{
                USART_Transmit('6');
 44c:	86 e3       	ldi	r24, 0x36	; 54
 44e:	8d de       	rcall	.-742    	; 0x16a <USART_Transmit>
                ml_consumption = CONS_5_UL;
                CurrentDuration->Seconds += seconds;
 450:	80 91 08 01 	lds	r24, 0x0108
 454:	18 0f       	add	r17, r24
            //    USART_Transmit(0x30 + seconds);
                seconds = 0;
 456:	10 92 08 01 	sts	0x0108, r1
            }
            ticks= 0 ;
 45a:	10 92 0a 01 	sts	0x010A, r1
 45e:	10 92 09 01 	sts	0x0109, r1
            
            CurrentDuration->Seconds += timerTicks / ONE_SECOND_TICKS;
 462:	80 91 0d 01 	lds	r24, 0x010D
 466:	90 91 0e 01 	lds	r25, 0x010E
 46a:	be 01       	movw	r22, r28
 46c:	3e d0       	rcall	.+124    	; 0x4ea <__udivmodhi4>
 46e:	16 0f       	add	r17, r22
            timerTicks = timerTicks % ONE_SECOND_TICKS;
 470:	90 93 0e 01 	sts	0x010E, r25
 474:	80 93 0d 01 	sts	0x010D, r24
            CurrentDuration->Minutes += CurrentDuration->Seconds / 60;
 478:	1f 9d       	mul	r17, r15
 47a:	81 2d       	mov	r24, r1
 47c:	11 24       	eor	r1, r1
 47e:	82 95       	swap	r24
 480:	86 95       	lsr	r24
 482:	87 70       	andi	r24, 0x07	; 7
            timeToSave               += CurrentDuration->Seconds / 60;
 484:	90 91 0c 01 	lds	r25, 0x010C
 488:	98 0f       	add	r25, r24
            CurrentDuration->Seconds  = CurrentDuration->Seconds % 60;
 48a:	80 9f       	mul	r24, r16
 48c:	10 19       	sub	r17, r0
 48e:	11 24       	eor	r1, r1
                        
            CurrentConsumption->MicroLiters += ml_consumption / 10;
            CurrentConsumption->Liters +=CurrentConsumption->MicroLiters / 1000000;
            CurrentConsumption->MicroLiters = CurrentConsumption->MicroLiters % 1000000;                        
                        
            if(timeToSave > 5){
 490:	96 30       	cpi	r25, 0x06	; 6
 492:	18 f4       	brcc	.+6      	; 0x49a <main+0x10a>
            ticks= 0 ;
            
            CurrentDuration->Seconds += timerTicks / ONE_SECOND_TICKS;
            timerTicks = timerTicks % ONE_SECOND_TICKS;
            CurrentDuration->Minutes += CurrentDuration->Seconds / 60;
            timeToSave               += CurrentDuration->Seconds / 60;
 494:	90 93 0c 01 	sts	0x010C, r25
 498:	02 c0       	rjmp	.+4      	; 0x49e <main+0x10e>
            CurrentConsumption->Liters +=CurrentConsumption->MicroLiters / 1000000;
            CurrentConsumption->MicroLiters = CurrentConsumption->MicroLiters % 1000000;                        
                        
            if(timeToSave > 5){
                //save data
                timeToSave = 0;
 49a:	10 92 0c 01 	sts	0x010C, r1
            }
            
            state &= ~IMPULSE;
 49e:	80 91 0b 01 	lds	r24, 0x010B
 4a2:	8e 7f       	andi	r24, 0xFE	; 254
 4a4:	80 93 0b 01 	sts	0x010B, r24
                //power_adc_disable();
                USART_Transmit(0x0D);
                USART_Transmit(0x0A);
#endif
                                
            break;
 4a8:	1a c0       	rjmp	.+52     	; 0x4de <main+0x14e>
        } 
        case ONE_SECOND_INT:{
            
            if(seconds > POWER_DOWN_TIMEOUT){
 4aa:	80 91 08 01 	lds	r24, 0x0108
 4ae:	8b 30       	cpi	r24, 0x0B	; 11
 4b0:	28 f0       	brcs	.+10     	; 0x4bc <main+0x12c>
                Timer2_Stop();
 4b2:	b1 de       	rcall	.-670    	; 0x216 <Timer2_Stop>
                //save data

                set_sleep_mode(SLEEP_MODE_PWR_DOWN); // Set sleep mode to Power-save
 4b4:	83 b7       	in	r24, 0x33	; 51
 4b6:	81 7f       	andi	r24, 0xF1	; 241
 4b8:	84 60       	ori	r24, 0x04	; 4
 4ba:	83 bf       	out	0x33, r24	; 51
            }
            state &= ~ONE_SECOND_INT;
 4bc:	80 91 0b 01 	lds	r24, 0x010B
 4c0:	8d 7f       	andi	r24, 0xFD	; 253
 4c2:	80 93 0b 01 	sts	0x010B, r24
            USART_Transmit('s');
 4c6:	83 e7       	ldi	r24, 0x73	; 115
 4c8:	50 de       	rcall	.-864    	; 0x16a <USART_Transmit>
            break;
 4ca:	09 c0       	rjmp	.+18     	; 0x4de <main+0x14e>
        }

        case BT_CONNECTED:{
        //    uint8_t adcv=0;
        //    uint8_t idx=5;
            state &= ~BT_CONNECTED;
 4cc:	10 92 0b 01 	sts	0x010B, r1
            USART_Transmit('a');
 4d0:	81 e6       	ldi	r24, 0x61	; 97
 4d2:	4b de       	rcall	.-874    	; 0x16a <USART_Transmit>
            
            Download_Function();
 4d4:	cb dd       	rcall	.-1130   	; 0x6c <Download_Function>
            
            break;
 4d6:	03 c0       	rjmp	.+6      	; 0x4de <main+0x14e>
        case IDLE:{
        //    USART_Transmit('i');
            break;
        }
        default:{
            state = IDLE;
 4d8:	10 92 0b 01 	sts	0x010B, r1
 4dc:	04 c0       	rjmp	.+8      	; 0x4e6 <main+0x156>
    }
    

        
        
        if(IDLE == state){
 4de:	80 91 0b 01 	lds	r24, 0x010B
 4e2:	81 11       	cpse	r24, r1
 4e4:	67 cf       	rjmp	.-306    	; 0x3b4 <main+0x24>
           // PORTC &=0xFE;
        // Execute sleep instruction
        sleep_cpu();                    
 4e6:	88 95       	sleep
 4e8:	65 cf       	rjmp	.-310    	; 0x3b4 <main+0x24>

000004ea <__udivmodhi4>:
 4ea:	aa 1b       	sub	r26, r26
 4ec:	bb 1b       	sub	r27, r27
 4ee:	51 e1       	ldi	r21, 0x11	; 17
 4f0:	07 c0       	rjmp	.+14     	; 0x500 <__udivmodhi4_ep>

000004f2 <__udivmodhi4_loop>:
 4f2:	aa 1f       	adc	r26, r26
 4f4:	bb 1f       	adc	r27, r27
 4f6:	a6 17       	cp	r26, r22
 4f8:	b7 07       	cpc	r27, r23
 4fa:	10 f0       	brcs	.+4      	; 0x500 <__udivmodhi4_ep>
 4fc:	a6 1b       	sub	r26, r22
 4fe:	b7 0b       	sbc	r27, r23

00000500 <__udivmodhi4_ep>:
 500:	88 1f       	adc	r24, r24
 502:	99 1f       	adc	r25, r25
 504:	5a 95       	dec	r21
 506:	a9 f7       	brne	.-22     	; 0x4f2 <__udivmodhi4_loop>
 508:	80 95       	com	r24
 50a:	90 95       	com	r25
 50c:	bc 01       	movw	r22, r24
 50e:	cd 01       	movw	r24, r26
 510:	08 95       	ret

00000512 <_exit>:
 512:	f8 94       	cli

00000514 <__stop_program>:
 514:	ff cf       	rjmp	.-2      	; 0x514 <__stop_program>
